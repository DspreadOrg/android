<p><em>QPOS Programming Guide</em></p>
<div class="toc">
<ul>
<li><a href="#change-list">Change List</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#programming-model">Programming Model</a></li>
<li><a href="#programming-interface">Programming Interface</a><ul>
<li><a href="#initialization">Initialization</a></li>
<li><a href="#get-device-information">Get Device Information</a></li>
<li><a href="#get-device-id">Get Device ID</a></li>
<li><a href="#start-transaction">Start Transaction</a></li>
<li><a href="#set-transaction-amount">Set Transaction Amount</a></li>
<li><a href="#magstripe-card-transaction">Magstripe Card Transaction</a><ul>
<li><a href="#decoding-track-data-encrypted-with-data-key-variant">Decoding Track Data Encrypted with Data Key Variant</a></li>
<li><a href="#decoding-track-data-encrypted-with-data-key">Decoding Track Data Encrypted with Data Key</a></li>
</ul>
</li>
<li><a href="#decoding-pin">Decoding PIN</a></li>
<li><a href="#chip-card-transaction">Chip Card Transaction</a><ul>
<li><a href="#start-chip-card-transaction">Start Chip Card Transaction</a></li>
<li><a href="#input-pin">Input PIN</a></li>
<li><a href="#set-time">Set Time</a></li>
<li><a href="#select-emv-application">Select EMV Application</a></li>
<li><a href="#online-request">Online Request</a></li>
<li><a href="#get-transaction-result">Get Transaction Result</a></li>
<li><a href="#batch-data-handling">Batch Data Handling</a></li>
<li><a href="#reversal-handling">Reversal Handling</a></li>
</ul>
</li>
<li><a href="#error-notification">Error Notification</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="change-list">Change List</h1>
<table>
<thead>
<tr>
<th>Version</th>
<th>Author</th>
<th>Date</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.1</td>
<td>Austin Wang</td>
<td>2013-05-01</td>
<td>Initially Added</td>
</tr>
<tr>
<td>1.0</td>
<td>Austin Wang</td>
<td>2013-09-01</td>
<td>Added EMV related function</td>
</tr>
<tr>
<td>1.1</td>
<td>Ausitn Wang</td>
<td>2014-03-01</td>
<td>Merge QPOS standard and EMV Card reader together</td>
</tr>
<tr>
<td>1.2</td>
<td>Austin Wang</td>
<td>2014-10-20</td>
<td>Added UART interface support for GES device</td>
</tr>
</tbody>
</table>
<h1 id="introduction">Introduction</h1>
<p>QPOS is a serial of mobile payment devices. It can communicate with the mobile device through audio jack, UART or USB cable. </p>
<p>QPOS standard, QPOS mini, QPOS Plus, EMV06, EMV08, GEA and GES are all QPOS products, some of them are with PINPAD embedded and some of them are only card readers without PINPAD.</p>
<p>This document aims to help readers for using the Android SDK of QPOS.</p>
<h1 id="programming-model">Programming Model</h1>
<p>All methods the SDK provided can be devided into three types:
1. Init methods；
2. Interactive methods；
3. Listener methods.</p>
<p>The application use the init method to init the EMV card reader hardware and get an instance of the Card Reader. It then can use the interactive methods to start the communication with the card reader. During the communication process, if any message returned from the Card reader, a listener method will be invoked by the SDK package.</p>
<p>To avoid the application block and improve the speed of  data interaction between the smart terminal and QPOS, the SDK framework is designed to work under asynchronous mode.</p>
<h1 id="programming-interface">Programming Interface</h1>
<h2 id="initialization">Initialization</h2>
<p>The Class named ‘QPOSService’ is the core of SDK library. Before the APP create this core instance with the parameter of “CommunicationMode mode”, the APP must register all the sub-functions in ‘QPOSServiceListener’. Below code snipplet shows how to init the SDK.</p>
<pre><code class="java">    private void open(CommunicationMode mode) {
        listener = new MyPosListener();
        pos = QPOSService.getInstance(mode);
        if (pos == null) {
            statusEditText.setText(&quot;CommunicationMode unknow&quot;);
            return;
        }
        pos.setConext(getApplicationContext());
        Handler handler = new Handler(Looper.myLooper());
        pos.initListener(handler, listener);
    }
</code></pre>

<p>The CommunicaitonMode can be </p>
<pre><code class="java">    public static enum CommunicationMode{
        AUDIO,
        BLUETOOTH_VER2,
        UART,
        USB
    }
</code></pre>

<p>The app should choose appropriate communication mode depend on it's hardware configuration.
Note, in the example above the app should realize the call back methods of MyPosListener.</p>
<p>The code below shows how to open the communication bridge with the open() method descripted above.</p>
<pre><code class="java">        if (//we want to use Audio Jack as communication mode) {
            open(CommunicationMode.AUDIO);
            posType = POS_TYPE.AUDIO;
            pos.openAudio();
        } else if (//we want to use UART as communication mode) {
            if (isUsb) {
                open(CommunicationMode.USB);
                posType = POS_TYPE.UART;
                pos.openUsb();
            }else {
                open(CommunicationMode.UART);
                posType = POS_TYPE.UART;
                pos.openUart();
            }

        } else {   //We will use Bluetooth
            open(CommunicationMode.BLUETOOTH_VER2);
            posType = POS_TYPE.BLUETOOTH;
            //...
        }
</code></pre>

<h2 id="get-device-information">Get Device Information</h2>
<p>The app can get the EMV cardreader information by issuing:</p>
<pre><code class="java">        pos.getQposInfo();
</code></pre>

<p>Note the pos is the instance of QPOSService, the app get it during the initialization process.</p>
<p>The device information will be returned on the below call back:</p>
<pre><code class="java">        @Override
        public void onQposInfoResult(Hashtable&lt;String, String&gt; posInfoData) {
            String isSupportedTrack1 = posInfoData.get(&quot;isSupportedTrack1&quot;) == null ? &quot;&quot;
                    : posInfoData.get(&quot;isSupportedTrack1&quot;);
            String isSupportedTrack2 = posInfoData.get(&quot;isSupportedTrack2&quot;) == null ? &quot;&quot;
                    : posInfoData.get(&quot;isSupportedTrack2&quot;);
            String isSupportedTrack3 = posInfoData.get(&quot;isSupportedTrack3&quot;) == null ? &quot;&quot;
                    : posInfoData.get(&quot;isSupportedTrack3&quot;);
            String bootloaderVersion = posInfoData.get(&quot;bootloaderVersion&quot;) == null ? &quot;&quot;
                    : posInfoData.get(&quot;bootloaderVersion&quot;);
            String firmwareVersion = posInfoData.get(&quot;firmwareVersion&quot;) == null ? &quot;&quot;
                    : posInfoData.get(&quot;firmwareVersion&quot;);
            String isUsbConnected = posInfoData.get(&quot;isUsbConnected&quot;) == null ? &quot;&quot;
                    : posInfoData.get(&quot;isUsbConnected&quot;);
            String isCharging = posInfoData.get(&quot;isCharging&quot;) == null ? &quot;&quot;
                    : posInfoData.get(&quot;isCharging&quot;);
            String batteryLevel = posInfoData.get(&quot;batteryLevel&quot;) == null ? &quot;&quot;
                    : posInfoData.get(&quot;batteryLevel&quot;);
            String hardwareVersion = posInfoData.get(&quot;hardwareVersion&quot;) == null ? &quot;&quot;
                    : posInfoData.get(&quot;hardwareVersion&quot;);
        }

</code></pre>

<p>App can knows the hardware , firmware version and hardware configuration based on the returned information.</p>
<h2 id="get-device-id">Get Device ID</h2>
<p>The device ID is use to indentifying one paticular EMV card reader. The app use below method to get the device ID:</p>
<pre><code class="java">        pos.getQposId();
</code></pre>

<p>The Device ID is returned to the app by below call back.</p>
<pre><code class="java">        @Override
        public void onQposIdResult(Hashtable&lt;String, String&gt; posIdTable) {
            String posId = posIdTable.get(&quot;posId&quot;) == null ? &quot;&quot; : posIdTable
                    .get(&quot;posId&quot;);
        }

</code></pre>

<h2 id="start-transaction">Start Transaction</h2>
<p>The app can start a magnatic swipe card transaction, or an EMV chip card transaction, by below method:</p>
<pre><code class="java">        pos.doTrade(60);
</code></pre>

<p>The only paramter is the time out value in second. If the user is using magnatic swipe card, after timeout seconds, the transaction will be timed out.</p>
<h2 id="set-transaction-amount">Set Transaction Amount</h2>
<p>The transaction amount can be set by:</p>
<pre><code class="java">            pos.setAmount(amount, cashbackAmount, &quot;156&quot;,
                                    TransactionType.GOODS);
</code></pre>

<p>the setAmount method can be called before start a transaction. If it was not called, a call back will be invoked by the SDK, giving app another chance to enter the transaction amount.</p>
<pre><code class="java">        @Override
        public void onRequestSetAmount() {
            pos.setAmount(amount, cashbackAmount, &quot;156&quot;,
                                    TransactionType.GOODS);
        }
</code></pre>

<p>The setAmount method has below parameters: 
1. amount : how much money in cents
2. cashbackAmount : reserved for future use 
3. currency code : US Dollar,  CNY, etc
4. transactionType : which kind of transaction to be started. The transaction type can be:</p>
<pre><code class="java">
    public static enum TransactionType {
        GOODS, 
        SERVICES, 
        CASH,
        CASHBACK, 
        INQUIRY, 
        TRANSFER, 
        ADMIN,
        CASHDEPOSIT,
        PAYMENT
    }
</code></pre>

<p>Transaction type is used mainly by the EMV Chip card transaction, for magnetic card, app can always use GOODS.</p>
<h2 id="magstripe-card-transaction">Magstripe Card Transaction</h2>
<p>Magstripe card transaction is pretty simple. 
After the app start a transaction, if the user use a magnatic card, below callback will be called feeding the app magnatic card related information. The app then use the information returned for further processing.</p>
<pre><code class="java">        @Override
        public void onDoTradeResult(DoTradeResult result,
                Hashtable&lt;String, String&gt; decodeData) {
            if (result == DoTradeResult.NONE) {
                statusEditText.setText(getString(R.string.no_card_detected));
            } else if (result == DoTradeResult.ICC) {
                statusEditText.setText(getString(R.string.icc_card_inserted));
                TRACE.d(&quot;EMV ICC Start&quot;);
                pos.doEmvApp(EmvOption.START);
            } else if (result == DoTradeResult.NOT_ICC) {
                statusEditText.setText(getString(R.string.card_inserted));
            } else if (result == DoTradeResult.BAD_SWIPE) {
                statusEditText.setText(getString(R.string.bad_swipe));
            } else if (result == DoTradeResult.MCR) {
                String maskedPAN = decodeData.get(&quot;maskedPAN&quot;);
                String expiryDate = decodeData.get(&quot;expiryDate&quot;);
                String cardHolderName = decodeData.get(&quot;cardholderName&quot;);
                String ksn = decodeData.get(&quot;ksn&quot;);
                String serviceCode = decodeData.get(&quot;serviceCode&quot;);
                String track1Length = decodeData.get(&quot;track1Length&quot;);
                String track2Length = decodeData.get(&quot;track2Length&quot;);
                String track3Length = decodeData.get(&quot;track3Length&quot;);
                String encTracks = decodeData.get(&quot;encTracks&quot;);
                String encTrack1 = decodeData.get(&quot;encTrack1&quot;);
                String encTrack2 = decodeData.get(&quot;encTrack2&quot;);
                String encTrack3 = decodeData.get(&quot;encTrack3&quot;);
                String partialTrack = decodeData.get(&quot;partialTrack&quot;);
                String pinKsn = decodeData.get(&quot;pinKsn&quot;);
                String trackksn = decodeData.get(&quot;trackksn&quot;);
                String pinBlock = decodeData.get(&quot;pinBlock&quot;);
                String encPAN = decodeData.get(&quot;encPAN&quot;);
                String trackRandomNumber = decodeData
                        .get(&quot;trackRandomNumber&quot;);
                String pinRandomNumber = decodeData.get(&quot;pinRandomNumber&quot;);
                            + &quot;\n&quot;;
                }
            } else if (result == DoTradeResult.NO_RESPONSE) {
                statusEditText.setText(getString(R.string.card_no_response));
            } else if (result == DoTradeResult.NO_UPDATE_WORK_KEY) {
                statusEditText.setText(&quot;not update work key&quot;);
            }
        }
</code></pre>

<p>Below table describes the meaning of each data element SDK returned:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>maskedPAN</td>
<td>Masked card number showing at most the first 6 and last 4 digits with in-between digits masked by “X”</td>
</tr>
<tr>
<td>expiryDate</td>
<td>4-digit in the form of YYMM in the track data</td>
</tr>
<tr>
<td>cardHolderName</td>
<td>The cardholder name as seen on the card. This can be up to 26 characters.</td>
</tr>
<tr>
<td>serviceCode</td>
<td>3-digit service code in the track data</td>
</tr>
<tr>
<td>track1Length</td>
<td>Length of Track 1 data</td>
</tr>
<tr>
<td>track2Length</td>
<td>Length of Track 2 data</td>
</tr>
<tr>
<td>track3Length</td>
<td>Length of Track 3 data</td>
</tr>
<tr>
<td>encTracks</td>
<td>Reserved</td>
</tr>
<tr>
<td>encTrack1</td>
<td>Encrypted track 1 data with T-Des encryption key derived from DATA-key to be generated with trackksn and IPEK</td>
</tr>
<tr>
<td>encTrack2</td>
<td>Encrypted track 2 data with T-Des encryption key derived from DATA-key to be generated with trackksn and IPEK</td>
</tr>
<tr>
<td>encTrack3</td>
<td>Encrypted track 3 data with T-Des encryption key derived from DATA-key to be generated with trackksn and IPEK</td>
</tr>
<tr>
<td>partialTrack</td>
<td>Reserved</td>
</tr>
<tr>
<td>trackksn</td>
<td>KSN of the track data</td>
</tr>
</tbody>
</table>
<p>The track data returned in the hashtable is encrytped. It can be encrypted by Dukpt Data Key Variant 3DES ECB mode, or by Dukpt Data Key 3DES CBC mode. Per ANSI X9.24 2009 version request, The later (Data Key with 3DES CBC mode) is usually a recommanded choice.</p>
<h3 id="decoding-track-data-encrypted-with-data-key-variant">Decoding Track Data Encrypted with Data Key Variant</h3>
<p>Below is an example of the data captured during a live magnatic transaction, the track data is encrypted using data key variant, in 3DES ECB mode:</p>
<pre><code>01-20 06:58:29.412: D/POS_SDK(3609): decodeData: {track3Length=0, track2Length=32, expiryDate=1011, encTrack3=, encPAN=, encTrack1=744B8A95FF1982CD63FB24D581FCD1A0590E7F6DD12B86ED1B1D26E687EA853A128598C16BE14964A34607452511C4B6CBDCACD72BEB566E32094937C18C2424, pinRandomNumber=, encTrack2=5E7E2D56D3496B2721EBD4C590031EB9D7883B75B97A71FF, trackRandomNumber=, trackksn=00000332100300E0000A, maskedPAN=622526XXXXXX5453, cardholderName=MR.ZHOU CHENG HAO         , partialTrack=, encTracks=5E7E2D56D3496B2721EBD4C590031EB9D7883B75B97A71FF, psamNo=, formatID=30, track1Length=68, pinKsn=, serviceCode=106, ksn=, pinBlock=}
01-20 06:58:29.413: D/POS_SDK(3609): swipe card:Card Swiped:Format ID: 30
01-20 06:58:29.413: D/POS_SDK(3609): Masked PAN: 622526XXXXXX5453
01-20 06:58:29.413: D/POS_SDK(3609): Expiry Date: 1011
01-20 06:58:29.413: D/POS_SDK(3609): Cardholder Name: MR.ZHOU CHENG HAO         
01-20 06:58:29.413: D/POS_SDK(3609): KSN: 
01-20 06:58:29.413: D/POS_SDK(3609): pinKsn: 
01-20 06:58:29.413: D/POS_SDK(3609): trackksn: 00000332100300E0000A
01-20 06:58:29.413: D/POS_SDK(3609): Service Code: 106
01-20 06:58:29.413: D/POS_SDK(3609): Track 1 Length: 68
01-20 06:58:29.413: D/POS_SDK(3609): Track 2 Length: 32
01-20 06:58:29.413: D/POS_SDK(3609): Track 3 Length: 0
01-20 06:58:29.413: D/POS_SDK(3609): Encrypted Tracks: 5E7E2D56D3496B2721EBD4C590031EB9D7883B75B97A71FF
01-20 06:58:29.413: D/POS_SDK(3609): Encrypted Track 1: 744B8A95FF1982CD63FB24D581FCD1A0590E7F6DD12B86ED1B1D26E687EA853A128598C16BE14964A34607452511C4B6CBDCACD72BEB566E32094937C18C2424
01-20 06:58:29.413: D/POS_SDK(3609): Encrypted Track 2: 5E7E2D56D3496B2721EBD4C590031EB9D7883B75B97A71FF
01-20 06:58:29.413: D/POS_SDK(3609): Encrypted Track 3: 
01-20 06:58:29.413: D/POS_SDK(3609): Partial Track: 
01-20 06:58:29.413: D/POS_SDK(3609): pinBlock: 
01-20 06:58:29.413: D/POS_SDK(3609): encPAN: 
01-20 06:58:29.413: D/POS_SDK(3609): trackRandomNumber: 
01-20 06:58:29.413: D/POS_SDK(3609): pinRandomNumber: 
</code></pre>

<p>The track ksn 00000332100300E0000A can be used to decode the track data:</p>
<p>Track 1 data:
744B8A95FF1982CD63FB24D581FCD1A0590E7F6DD12B86ED1B1D26E687EA853A128598C16BE14964A34607452511C4B6CBDCACD72BEB566E32094937C18C2424</p>
<p>Track 2 data:
5E7E2D56D3496B2721EBD4C590031EB9D7883B75B97A71FF</p>
<p>Below python script demostrate how to decode track data encrypted with DataKey Variant in ECB mode:</p>
<pre><code class="python">def GetDataKeyVariant(ksn, ipek):
    key = GetDUKPTKey(ksn, ipek)
    key = bytearray(key)
    key[5] ^= 0xFF
    key[13] ^= 0xFF
    return str(key)

def TDES_Dec(data, key):
    t = triple_des(key, ECB, padmode=None)
    res = t.decrypt(data)
    return res

def decrypt_card_info(ksn, data):
    BDK = unhexlify(&quot;0123456789ABCDEFFEDCBA9876543210&quot;)
    ksn = unhexlify(ksn)
    data = unhexlify(data)
    IPEK = GenerateIPEK(ksn, BDK)
    DATA_KEY_VAR = GetDataKeyVariant(ksn, IPEK)
    print hexlify(DATA_KEY_VAR)
    res = TDES_Dec(data, DATA_KEY_VAR)
    return hexlify(res)
</code></pre>

<p>Using data key variant to decrypt track 1, will get:</p>
<pre><code>16259249 54964104 16598554 553FADC8 EEA8BF50 23A25BA7 02886F00 00000000 0003E450 45145059 15D44964 10653590 41041041 F0000000 00000000 00000000
</code></pre>

<p>Each character in Track 1 is 6 bits in length, 4 characters are packed into 3 bytes. Each character is mapped from 0x20 to 0x5F. So to get the real ASCII value of each charactor, you need to add 0x20 to each decoded 6 bits.</p>
<pre><code>For example, the leading 3 bytes of above track 1 data is 16,25,92

Which in binary is: 00010110 00100101 10010010
Unpacked them to 4 bytes: 000101 100010 010110 010010
Which in binary is:05221612
Add 0x20 to each byte:25423632
Which is in ASCII :%B62
</code></pre>

<p>Using data key variant to decrypt track 2, will get:</p>
<pre><code>62252600 06685453 D1011106 17426936 FFFFFFFF FFFFFFFF 
</code></pre>

<p>Each character in Track 2 &amp; Track 3 is 4 bits in length. 2 characters are packed into 1 byte and padded with zero before encryption</p>
<h3 id="decoding-track-data-encrypted-with-data-key">Decoding Track Data Encrypted with Data Key</h3>
<p>Below is another example, the track data is encrypted using data key whith 3DES CBC mode (per ANSI X9.24 2009 version request)</p>
<pre><code>01-21 04:46:26.764: D/POS_SDK(30241): decodeData: {track3Length=0, track2Length=32, expiryDate=1011, encTrack3=, encPAN=, encTrack1=22FB2E931F3EFAFC8C3899AB779F3719E75D392365DB748EEA789560EEB7714D84AB7FFA5B2E162C9BD566D03DCD240FC9D316CAC4015B782294365F9062CA0A, pinRandomNumber=, encTrack2=153CEE49576C0B709515946D991CB48368FEA0375837ECA6, trackRandomNumber=, trackksn=00000332100300E00002, maskedPAN=622526XXXXXX5453, cardholderName=MR.ZHOU CHENG HAO         , partialTrack=, encTracks=153CEE49576C0B709515946D991CB48368FEA0375837ECA6, psamNo=, formatID=30, track1Length=68, pinKsn=, serviceCode=106, ksn=, pinBlock=}
01-21 04:46:26.766: D/POS_SDK(30241): swipe card:Card Swiped:Format ID: 30
01-21 04:46:26.766: D/POS_SDK(30241): Masked PAN: 622526XXXXXX5453
01-21 04:46:26.766: D/POS_SDK(30241): Expiry Date: 1011
01-21 04:46:26.766: D/POS_SDK(30241): Cardholder Name: MR.ZHOU CHENG HAO         
01-21 04:46:26.766: D/POS_SDK(30241): KSN: 
01-21 04:46:26.766: D/POS_SDK(30241): pinKsn: 
01-21 04:46:26.766: D/POS_SDK(30241): trackksn: 00000332100300E00002
01-21 04:46:26.766: D/POS_SDK(30241): Service Code: 106
01-21 04:46:26.766: D/POS_SDK(30241): Track 1 Length: 68
01-21 04:46:26.766: D/POS_SDK(30241): Track 2 Length: 32
01-21 04:46:26.766: D/POS_SDK(30241): Track 3 Length: 0
01-21 04:46:26.766: D/POS_SDK(30241): Encrypted Tracks: 153CEE49576C0B709515946D991CB48368FEA0375837ECA6
01-21 04:46:26.766: D/POS_SDK(30241): Encrypted Track 1: 22FB2E931F3EFAFC8C3899AB779F3719E75D392365DB748EEA789560EEB7714D84AB7FFA5B2E162C9BD566D03DCD240FC9D316CAC4015B782294365F9062CA0A
01-21 04:46:26.766: D/POS_SDK(30241): Encrypted Track 2: 153CEE49576C0B709515946D991CB48368FEA0375837ECA6
01-21 04:46:26.766: D/POS_SDK(30241): Encrypted Track 3: 
01-21 04:46:26.766: D/POS_SDK(30241): Partial Track: 
01-21 04:46:26.766: D/POS_SDK(30241): pinBlock: 
01-21 04:46:26.766: D/POS_SDK(30241): encPAN: 
01-21 04:46:26.766: D/POS_SDK(30241): trackRandomNumber: 
01-21 04:46:26.766: D/POS_SDK(30241): pinRandomNumber: 
</code></pre>

<p>Below python script demostrate how to decode track data encrypted with DataKey in CBC mode:</p>
<pre><code class="python">def GetDataKeyVariant(ksn, ipek):
    key = GetDUKPTKey(ksn, ipek)
    key = bytearray(key)
    key[5] ^= 0xFF
    key[13] ^= 0xFF
    return str(key) 

def GetDataKey(ksn, ipek):
    key = GetDataKeyVariant(ksn, ipek)
    return str(TDES_Enc(key,key))

def TDES_Dec(data, key):
    t = triple_des(key, CBC, &quot;\0\0\0\0\0\0\0\0&quot;,padmode=None)
    res = t.decrypt(data)
    return res

def decrypt_card_info(ksn, data):
    BDK = unhexlify(&quot;0123456789ABCDEFFEDCBA9876543210&quot;)
    ksn = unhexlify(ksn)
    data = unhexlify(data)
    IPEK = GenerateIPEK(ksn, BDK)
    DATA_KEY = GetDataKey(ksn, IPEK)
    print hexlify(DATA_KEY)
    res = TDES_Dec(data, DATA_KEY)
    return hexlify(res)

</code></pre>

<p>The decoded track 1 and track 2 data are the same as the track data we got in previous section.</p>
<h2 id="decoding-pin">Decoding PIN</h2>
<p>The QPOS will also send the encryted PIN to the mobile application:</p>
<pre><code>10-07 11:37:49.571: V/vahid(20753): ???? ????? ??:Format ID: 30
10-07 11:37:49.571: V/vahid(20753): Masked PAN: 622106XXXXXX1111
10-07 11:37:49.571: V/vahid(20753): Expiry Date: 1605
10-07 11:37:49.571: V/vahid(20753): Cardholder Name:
10-07 11:37:49.571: V/vahid(20753): KSN:
10-07 11:37:49.571: V/vahid(20753): pinKsn: 00000332100300E000E6
10-07 11:37:49.571: V/vahid(20753): trackksn: 00000332100300E000C6
10-07 11:37:49.571: V/vahid(20753): Service Code: 100
10-07 11:37:49.571: V/vahid(20753): Track 1 Length: 0
10-07 11:37:49.571: V/vahid(20753): Track 2 Length: 37
10-07 11:37:49.571: V/vahid(20753): Track 3 Length: 37
10-07 11:37:49.571: V/vahid(20753): Encrypted Tracks: 47B35616888BB17A055BE87FBAC76DCDD3EFFACA5F1C901047B35616888BB17A055BE87FBAC76DCDD3EFFACA5F1C901060325F039768CE5760325F039768CE5760325F039768CE5760325F039768CE57
10-07 11:37:49.571: V/vahid(20753): Encrypted Track 1:
10-07 11:37:49.571: V/vahid(20753): Encrypted Track 2: 47B35616888BB17A055BE87FBAC76DCDD3EFFACA5F1C9010
10-07 11:37:49.571: V/vahid(20753): Encrypted Track 3: 47B35616888BB17A055BE87FBAC76DCDD3EFFACA5F1C901060325F039768CE5760325F039768CE5760325F039768CE5760325F039768CE57
10-07 11:37:49.571: V/vahid(20753): Partial Track:
10-07 11:37:49.571: V/vahid(20753): pinBlock: 377D28B8C7EF080A
10-07 11:37:49.571: V/vahid(20753): encPAN:
10-07 11:37:49.571: V/vahid(20753): trackRandomNumber:
10-07 11:37:49.571: V/vahid(20753): pinRandomNumber:
</code></pre>

<p>Decode the Track 2 data using the method descripted before: 
6221061055111111D16051007832281716058FFFFFFFFFFF</p>
<p>Below python script demostrate how to decode PINBLOCK:</p>
<pre><code class="python">def GetPINKeyVariant(ksn, ipek):
    key = GetDUKPTKey(ksn, ipek)
    key = bytearray(key)
    key[7] ^= 0xFF
    key[15] ^= 0xFF
    return str(key)

def TDES_Dec(data, key):
    t = triple_des(key, ECB, padmode=None)
    res = t.decrypt(data)
    return res

def decrypt_pinblock(ksn, data):
    BDK = unhexlify(&quot;0123456789ABCDEFFEDCBA9876543210&quot;)
    ksn = unhexlify(ksn)
    data = unhexlify(data)
    IPEK = GenerateIPEK(ksn, BDK)
    PIN_KEY = GetPINKeyVariant(ksn, IPEK)
    print hexlify(PIN_KEY)
    res = TDES_Dec(data, PIN_KEY)
    return hexlify(res)

if __name__ == &quot;__main__&quot;:
    KSN = &quot;00000332100300E000E6&quot;
    DATA = &quot;377D28B8C7EF080A&quot;
    #DATA=&quot;153CEE49576C0B709515946D991CB48368FEA0375837ECA6&quot;
    print decrypt_pinblock(KSN, DATA)

</code></pre>

<p>The decrypted PINBLOCK (formated Pin data) is: 0411019efaaeeeee
The real PIN value can be caculated using formated pin data and PAN as inputs, according to ANSI X9.8. Below is an example:</p>
<p>1) PAN: 6221061055111111
2) 12 right most PAN digits without checksum: 106105511111
3) Add 0000 to the left: 0000106105511111
4) XOR (#3) and Formated PIN Data </p>
<p>XOR (0000106105511111, 0411019efaaeeeee) = 041111FFFFFFFFFF
In our example, the plain PIN is 4 bytes in length with data "1111"</p>
<h2 id="chip-card-transaction">Chip Card Transaction</h2>
<p>EMV Chip card transaction is much more complicate than magnatic swipe card transaction. The EMV kernel inside the device may need a lot of information to process the transaction, including:</p>
<ol>
<li>PIN from the card holder</li>
<li>Current time from the application</li>
<li>Preferred EMV application from card holder</li>
<li>The process result from the bank (card issuer) for the transaction</li>
</ol>
<h3 id="start-chip-card-transaction">Start Chip Card Transaction</h3>
<p>The app start the EMV transaction by calling</p>
<pre><code class="java">    pos.doEmvApp(EmvOption.START);
</code></pre>

<p>This is usually happens inside the call back of onDoTradeResult(), as below demo code shows:</p>
<pre><code class="java">        @Override
        public void onDoTradeResult(DoTradeResult result,
                Hashtable&lt;String, String&gt; decodeData) {
            if (result == DoTradeResult.NONE) {
                statusEditText.setText(getString(R.string.no_card_detected));
            } else if (result == DoTradeResult.ICC) {
                statusEditText.setText(getString(R.string.icc_card_inserted));
                TRACE.d(&quot;EMV ICC Start&quot;)
                pos.doEmvApp(EmvOption.START);
            } else if (result == DoTradeResult.NOT_ICC) {
                statusEditText.setText(getString(R.string.card_inserted));
            } else if (result == DoTradeResult.BAD_SWIPE) {
                statusEditText.setText(getString(R.string.bad_swipe));
            } else if (result == DoTradeResult.MCR) {
                //handling MSR transaction
            }
</code></pre>

<h3 id="input-pin">Input PIN</h3>
<p>The PIN information can be sent to the EMV kernel by:</p>
<pre><code class="java">        @Override
        public void onRequestSetPin() {
                pos.sendPin(&quot;123456&quot;);
                //pos.emptyPin();    //Bypass PIN Entry
                //pos.cancelPin();   //Cancel the transaction
        }
</code></pre>

<p>Note, the kernel will not call the callback if PIN is not required for the transaction, or if the QPOS itself is with an embedded PINPAD.</p>
<p>If the user do not want to input PIN, the applicaiton can bypass PIN enter by calling </p>
<pre><code class="java">    pos.emptyPin();
</code></pre>

<p>if the user want to cancel the transaction, the app should call</p>
<pre><code class="java">    pos.cancelPin();
</code></pre>

<h3 id="set-time">Set Time</h3>
<p>The current time information can be sent to the EMV kernel by:</p>
<pre><code class="java">        @Override
        public void onRequestTime() {
            String terminalTime = new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;)
                    .format(Calendar.getInstance().getTime());
            pos.sendTime(terminalTime);
        }
</code></pre>

<h3 id="select-emv-application">Select EMV Application</h3>
<p>If there is multiple EMV applications inside one Chip card, the SDK will ask the user to choose one application from a list:</p>
<pre><code class="java">        @Override
        public void onRequestSelectEmvApp(ArrayList&lt;String&gt; appList) {
                pos.selectEmvApp(position);   //position is the index of the chosen application
                //pos.cancelSelectEmvApp();   //Cancel the transaction
        }

</code></pre>

<p>The chosen application is sending to the EMV kernel by </p>
<pre><code class="java">        pos.selectEmvApp(position)
</code></pre>

<h3 id="online-request">Online Request</h3>
<p>If the EMV kernel found the transaction need to go online, below call back will be called.</p>
<pre><code class="java">        @Override
        public void onRequestOnlineProcess(String tlv) {
             //sending online message tlv data to issuer
             ....
             //send the received online processing result to POS
             pos.sendOnlineProcessResult(&quot;8A023030&quot;);
        }
</code></pre>

<p>Below is an exmple of tlv data received by onRequestOnlineProcess:</p>
<pre><code>2014-08-27 17:52:21.210 qpos-ios-demo[391:60b] alertView.title = Online process requested.
2014-08-27 17:52:21.211 qpos-ios-demo[391:60b] hideAlertView
2014-08-27 17:52:21.221 qpos-ios-demo[391:60b] onRequestOnlineProcess = {
    tlv = 5F200220204F08A0000003330101015F24032312319F160F4243544553542031323334353637389F21031752139A031408279F02060000000000019F03060000000000009F34034203009F120A50424F43204445424954C409623061FFFFFFFF5284C10A00000332100300E00003C708A68701E68CB34BDEC00A00000332100300E00003C2820150E84B5D0D2AA9F40A2EFCC52424C52DDE2ABB1A07F8B53A8F37837A9AA4BF7200CC55AA1480ED5665AEC03DFE493248AEEA126345F1C2BA0EB0AA82546CC0AF5E6F4E40D7F9A3788C8F35B33F5AF1D85231D77FCE112A1C9D2AFF3679C3C46456232D32FD0D2AAF288CFD4CC52C1F33F128C247296C9E46647D930ACED5B34CFD0C2A823B3F91BEC60E8280005CB96C3EFCCC352F0A30F77A2A033361B5C2C720D8B6E85BFA3C589ADBD6FAF15D3C520085A5276B736860441BB15DBF8FA537708654EE90E32C194D1487362498F59346706FD797DFC8DD28FCF31E7D49886BA62779EC42411A54F03FE22B9431969B780E8280005CB96C3EEF460C1F76C0F2217EAC9B999E3E03128A93A11A4FC6885E4106A4EA4D815D10900AC6AC95E3325D585CB8678AE17A4DEE4C45E2E44209B9493B5FD94F3F46CCF730CD8FED9430B7574CE670018A94907B2AA4B475A93ABF;
}
</code></pre>

<p>The tlv data can be decoded using the online EMVlab tool:</p>
<p>http://www.emvlab.org/tlvutils/?data=5F200220204F08A0000003330101015F24032312319F160F4243544553542031323334353637389F21031752139A031408279F02060000000000019F03060000000000009F34034203009F120A50424F43204445424954C409623061FFFFFFFF5284C10A00000332100300E00003C708A68701E68CB34BDEC00A00000332100300E00003C2820150E84B5D0D2AA9F40A2EFCC52424C52DDE2ABB1A07F8B53A8F37837A9AA4BF7200CC55AA1480ED5665AEC03DFE493248AEEA126345F1C2BA0EB0AA82546CC0AF5E6F4E40D7F9A3788C8F35B33F5AF1D85231D77FCE112A1C9D2AFF3679C3C46456232D32FD0D2AAF288CFD4CC52C1F33F128C247296C9E46647D930ACED5B34CFD0C2A823B3F91BEC60E8280005CB96C3EFCCC352F0A30F77A2A033361B5C2C720D8B6E85BFA3C589ADBD6FAF15D3C520085A5276B736860441BB15DBF8FA537708654EE90E32C194D1487362498F59346706FD797DFC8DD28FCF31E7D49886BA62779EC42411A54F03FE22B9431969B780E8280005CB96C3EEF460C1F76C0F2217EAC9B999E3E03128A93A11A4FC6885E4106A4EA4D815D10900AC6AC95E3325D585CB8678AE17A4DEE4C45E2E44209B9493B5FD94F3F46CCF730CD8FED9430B7574CE670018A94907B2AA4B475A93ABF%0D%0A</p>
<p>As we can see from the decoded table:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Tag Name</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>5F20</td>
<td>Cardholder Name</td>
<td></td>
</tr>
<tr>
<td>4F</td>
<td>AID</td>
<td>A000000333010101</td>
</tr>
<tr>
<td>5F24</td>
<td>App Expiration Date</td>
<td>231231</td>
</tr>
<tr>
<td>9F16</td>
<td>Merchant ID</td>
<td>B C T E S T 1 2 3 4 5 6 7 8</td>
</tr>
<tr>
<td>9F21</td>
<td>Transaction Time</td>
<td>175213</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>C4</td>
<td>Masked PAN</td>
<td>623061FFFFFFFF5284</td>
</tr>
<tr>
<td>C1</td>
<td>KSN(PIN)</td>
<td>00000332100300E00003</td>
</tr>
<tr>
<td>C7</td>
<td>PINBLOCK</td>
<td>A68701E68CB34BDE</td>
</tr>
<tr>
<td>C0</td>
<td>KSN Online Msg</td>
<td>00000332100300E00003</td>
</tr>
<tr>
<td>C2</td>
<td>Online Message</td>
<td>E84B5D0D2AA9F40A2EFC....</td>
</tr>
</tbody>
</table>
<p>Inside the table, there are:
1. Some EMV TAGs (5F20,4F,5F24 ...) with plain text value. 
2. Some Proprietary tags starting with 0xC, in our case C4,C1,C7,C0 and C2.</p>
<p>The defination of proprietary tags can be found below:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Name</th>
<th>Length(Bytes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>C0</td>
<td>KSN of Online Msg</td>
<td>10</td>
</tr>
<tr>
<td>C1</td>
<td>KSN of PIN</td>
<td>10</td>
</tr>
<tr>
<td>C2</td>
<td>Online Message(E)</td>
<td>var</td>
</tr>
<tr>
<td>C3</td>
<td>KSN of Batch/Reversal Data</td>
<td>10</td>
</tr>
<tr>
<td>C4</td>
<td>Masked PAN</td>
<td>0~10</td>
</tr>
<tr>
<td>C5</td>
<td>Batch Data</td>
<td>var</td>
</tr>
<tr>
<td>C6</td>
<td>Reversal Data</td>
<td>var</td>
</tr>
<tr>
<td>C7</td>
<td>PINBLOCK</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>It's the responsibility of the app to handle the online message string, sending them to the bank( the cardd issuer), and check the bank processing result.</p>
<p>The value of tag C2 is the encrypted Online Message, usually the app need to send it to the back end system, along with the tag C0 value. The backend system can derive the 3DES key from C0 value, and decrypt the C2 value and get the real online data in plain text format.</p>
<p>In case encrypted PIN is needed by the transaction, the app can also send the value of tag C7,C1 to back end system.</p>
<p>The example above is just a demostration. "8A023030" is a fake result from back end system.</p>
<p>As an exmple of decoding the online message, please find below some demo scripts:</p>
<pre><code class="python">
def decrypt_icc_info(ksn, data):
    BDK = unhexlify(&quot;0123456789ABCDEFFEDCBA9876543210&quot;)
    ksn = unhexlify(ksn)
    data = unhexlify(data)
    IPEK = GenerateIPEK(ksn, BDK)
    DATA_KEY = GetDataKey(ksn, IPEK)
    print hexlify(DATA_KEY)
    res = TDES_Dec(data, DATA_KEY)
    return hexlify(res)

if __name__ == &quot;__main__&quot;:
    KSN = &quot;00000332100300E00003&quot;
    DATA = &quot;E84B5D0D2AA9F40A2EFCC52424C52DDE2ABB1A07F8B53A8F37837A9AA4BF7200CC55AA1480ED5665AEC03DFE493248AEEA126345F1C2BA0EB0AA82546CC0AF5E6F4E40D7F9A3788C8F35B33F5AF1D85231D77FCE112A1C9D2AFF3679C3C46456232D32FD0D2AAF288CFD4CC52C1F33F128C247296C9E46647D930ACED5B34CFD0C2A823B3F91BEC60E8280005CB96C3EFCCC352F0A30F77A2A033361B5C2C720D8B6E85BFA3C589ADBD6FAF15D3C520085A5276B736860441BB15DBF8FA537708654EE90E32C194D1487362498F59346706FD797DFC8DD28FCF31E7D49886BA62779EC42411A54F03FE22B9431969B780E8280005CB96C3EEF460C1F76C0F2217EAC9B999E3E03128A93A11A4FC6885E4106A4EA4D815D10900AC6AC95E3325D585CB8678AE17A4DEE4C45E2E44209B9493B5FD94F3F46CCF730CD8FED9430B7574CE670018A94907B2AA4B475A93ABF&quot;
    print decrypt_icc_info(KSN, DATA)

</code></pre>

<p>The decoded icc online message looks like:</p>
<p>http://www.emvlab.org/tlvutils/?data=708201479f02060000000000015a096230615710101752845713623061571010175284d231222086038214069f9f101307010103a02000010a01000000000013f6c0429f160f4243544553542031323334353637389f4e0f61626364000000000000000000000082027c008e0e000000000000000042031e031f005f24032312315f25031307304f08a0000003330101019f0702ff009f0d05d8609ca8009f0e0500100000009f0f05d8689cf8009f2608059aae950d0b7a679f2701809f3602008d9c01009f3303e0f8c89f34034203009f3704c1cdd24a9f3901059f4005f000f0a0019505088004e0009b02e8008408a0000003330101019a031408275f2a0201565f3401019f03060000000000009f0902008c9f1a0206439f1e0838333230314943439f3501229f4104000000015f200220205f300202205f28020156500a50424f432044454249540000000000</p>
<p>All the online message in embedded inside tag 0x70, the ending 00 are paddings for 3DES encryption.</p>
<h3 id="get-transaction-result">Get Transaction Result</h3>
<p>The application will be notified by the SDK regarding the transaction result by:</p>
<pre><code class="java">        @Override
        public void onRequestTransactionResult(
            TransactionResult transactionResult) {
            if (transactionResult == TransactionResult.APPROVED) {
            } else if (transactionResult == TransactionResult.TERMINATED) {
            } else if (transactionResult == TransactionResult.DECLINED) {
            } else if (transactionResult == TransactionResult.CANCEL) {
            } else if (transactionResult == TransactionResult.CAPK_FAIL) {
            } else if (transactionResult == TransactionResult.NOT_ICC) {
            } else if (transactionResult == TransactionResult.SELECT_APP_FAIL) {
            } else if (transactionResult == TransactionResult.DEVICE_ERROR) {
            } else if (transactionResult == TransactionResult.CARD_NOT_SUPPORTED) {
            } else if (transactionResult == TransactionResult.MISSING_MANDATORY_DATA) {
            } else if (transactionResult == TransactionResult.CARD_BLOCKED_OR_NO_EMV_APPS) {
            } else if (transactionResult == TransactionResult.INVALID_ICC_DATA) {
            }        
        }
      }
</code></pre>

<h3 id="batch-data-handling">Batch Data Handling</h3>
<p>When the transaction is finished. The batch data will be returned to the application by below callback.</p>
<pre><code class="java">        @Override
        public void onRequestBatchData(String tlv) {
        }
</code></pre>

<p>Note, if there is issuer's script result inside the tlv, the mobile app need to feedback it to the bank.
Decoding the tlv inside onRequestBatchData is similar to decoding onRequestOnlineProcess. </p>
<h3 id="reversal-handling">Reversal Handling</h3>
<p>If the EMV chip card refuse the transaction, but the transaction was approved by the issuer. A reversal procedure should be initiated by the mobile app. The requred data for doing reversal can be got by below call back:</p>
<pre><code class="java">        @Override
        public void onReturnReversalData(String tlv) {
            ...
        }
</code></pre>

<h2 id="error-notification">Error Notification</h2>
<p>During the transaction, if there is anything abnormal happened, the onError callback will be called.</p>
<pre><code class="java">        @Override
        public void onError(Error errorState) {
            if (errorState == Error.CMD_NOT_AVAILABLE) {
            } else if (errorState == Error.TIMEOUT) {
            } else if (errorState == Error.DEVICE_RESET) {
            } else if (errorState == Error.UNKNOWN) {
            } else if (errorState == Error.DEVICE_BUSY) {
            } else if (errorState == Error.INPUT_OUT_OF_RANGE) {
            } else if (errorState == Error.INPUT_INVALID_FORMAT) {
            } else if (errorState == Error.INPUT_ZERO_VALUES) {
            } else if (errorState == Error.INPUT_INVALID) {
            } else if (errorState == Error.CASHBACK_NOT_SUPPORTED) {
            } else if (errorState == Error.CRC_ERROR) {
            } else if (errorState == Error.COMM_ERROR) {
            } else if (errorState == Error.MAC_ERROR) {
            } else if (errorState == Error.CMD_TIMEOUT) {
            }
        }

</code></pre>